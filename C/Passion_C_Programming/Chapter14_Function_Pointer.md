함수의 인자로 배열 전달
-----------------------

```C
int main(void){
  int arr[3] = {1,2,3};
  SimpleFunc(arr);
}

void SimpleFunc(int * param){ //매개변수를 int param[]으로 대체 가능
  ...
}
```

-	함수 호출 시 전달되는 인자의 값은 매개변수에 복사가 된다.<br><br>
-	매개변수로 배열을 선언할 수 없기 때문에, 함수 내에서 배열에 접근할 수 있도록 배열의 주소 값을 전달한다.<br><br>
-	SimpleFunc 함수의 매개변수는 int형 포인터 변수로 선언된다.<br><br>
-	함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없다.<br><br>
-	함수 내부에서 sizeof 연산을 할 경우, 배열의 크기가 반환되지 않고 매개변수인 포인터 변수의 크기가 반환되기 때문이다.<br><br>

Call-by-value vs. Call-by-reference
-----------------------------------

-	함수 호출 시 단순히 값을 전달하는 형태를 Call-by-value, 메모리의 접근에 사용되는 주소 값을 전달하는 형태를 Call-by-reference라고 한다.<br><br>
-	대표적으로 `scanf()` 함수에서 입력값을 저장하는 대상이 되는 변수에 & 연산자를 붙이는 이유이다.<br><br>
-	메모리 주소 값을 알아야 대상 변수에 접근하여 값을 채워 넣을 수 있기 때문이다.<br><br>
-	반면 문자열은 그 자체로 배열의 주소값을 반환하기 때문에 & 연산자를 사용하지 않는다.<br><br>

포인터 대상의 const 선언
------------------------

```C
int main(void){
  int num = 20;
  const int * ptr = &num;
  *ptr = 30; //컴파일 에러
  num = 40; //컴파일 성공

  int num2 = 15;
  int * const ptr2 = &num;
  ptr2 = &num2; //컴파일 에러
  *ptr2 = 40; //컴파일 성공
}
```

-	포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는 의미이다.<br><br>
-	그러나 실제 변수 num이 상수화되는 것은 아니다.<br><br>
-	반면 포인터 변수 ptr2는 상수가 되어 주소 값이 한 번 저장되면 변경이 불가능하다는 의미이다.<br><br>
-	그러나 ptr2는 저장된 값을 변경하는 연산에 있어서 문제가 되지 않는다.<br><br>
-	`const int * const ptr = &num` 처럼 두 가지 형태의 const 선언을 동시에 할 수 있다.<br><br>
-	const 선언을 통해 프로그램 코드의 안정성을 높인다.<br><br>

---

Reference
---------

-	열혈 C 프로그래밍 (윤성우 저) Chapter 14
