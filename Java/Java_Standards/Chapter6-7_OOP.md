Static
------

-	일반적으로 static 키워드가 붙은 변수 및 메서드 등은 클래스가 메모리에 로드될 때 생성된다.<br><br>
-	클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우 인스턴스를 생성해야 하며, 그 외에는 인스턴스 멤버를 직접 사용할 수 없다.<br><br>
-	인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.<br><br>

변수의 초기화
-------------

-	클래스 변수 및 인스턴스 변수 등 멤버 변수와 배열의 초기화는 선택적이지만, 지역 변수의 초기화는 필수이다.<br><br>
-	명시적 초기화가 간단하지만, 보다 복잡한 초기화 작업이 필요할 때 초기화 블럭과 생성자를 사용한다.<br><br>

Initialization Block
--------------------

```Java
class InitBlock{
static { /* 클래스 초기화 블럭 */ }
{ /* 인스턴스 초기화 블럭 */ }
}
```

-	클래스 초기화 블럭은 클래스 변수, 인스턴스 초기화 블럭은 인스턴스 변수의 복잡한 초기화에 사용된다.<br><br>
-	클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한 번만 수행되며, 인스턴스 초기화 블럭은 인스턴스 생성 때 마다 수행된다.<br><br>
-	여러 생성자들에서 중복되는 부분은 초기화 블럭으로 처리해준다.<br><br>
-	생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.<br><br>
-	초기화 순서는 기본값, 명시적 초기화, 초기화 블럭, 생성자 순이다.<br><br>
-	생성자와 초기화 블럭은 상속되지 않는다.<br><br>

Overriding
----------

-	오버라이딩 메서드는 조상 클래스의 메서드와 선언부가 일치해야 한다.<br><br>
-	접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 설정할 수 없다.<br><br>
-	조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.<br><br>
-	오버로딩은 기존에 없는 새로운 메서드를 정의하는 것이라면, 오버라이딩은 상속받은 메서드의 내용을 변경하는 것이다.<br><br>

super
-----

```java
String getLocation(){
  //return "x + y" + "z"
  return super.getLocation() + "z";
}
```

-	자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.<br><br>
-	참조 변수로 인스턴스 자신을 가리키는 키워드 this 처럼, super 역시 static 메서드에서는 사용이 불가능하다.<br><br>
-	조상 클래스의 메서드 내용에 추가적으로 작업을 덧붙이는 경우 super를 사용한다.<br><br>
-	조상 클래스의 메서드가 변경되더라도 변경된 내용이 자손에 자동 반영되기 때문이다.<br><br>
-	`super()` 메서드는 조상 클래스의 생성자를 호출하는데 사용되며, 컴파일러는 자동으로 해당 메서드를 자손 클래스 생성자의 첫 줄에 삽입한다.<br><br>
-	조상 클래스의 멤버 변수는 조상의 생성자에 의해 초기화되도록 한다.<br><br>

static import
-------------

```java
import static java.lang.Integer.*;
```

-	static import를 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.<br><br>

final
-----

-	final 메서드는 오버라이딩이 불가능하며, final 클래스는 자손 클래스를 정의할 수 없다.<br><br>
-	생성자를 이용해 인스턴스의 final 멤버 변수를 초기화한다.<br><br>

생성자의 접근 제어자
--------------------

```java
class Singleton{
  private Singleton(){}
  private static Singleton s = new Singleton();
  public static Singleton getInstance(){
    return s;
  }  
}
```

-	생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없어 인스턴스 생성이 불가능하다.<br><br>
-	그러나 클래스 내부에서 인스턴스를 생성하여 반환하는 방식을 이용할 수 있다.<br><br>
-	인스턴스를 생성하지 않고 사용하기 위해 static 선언을 한다.<br><br>
-	생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없기 때문에 final 클래스임을 명시한다.<br><br>

Polymorphism
------------

-	다형성이란 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조하는 것을 의미한다.<br><br>
-	자손 타입의 참조 변수로 조상 클래스의 인스턴스를 참조할 수 없다.<br><br>
-	조상 - 자손간 참조 변수 타입의 형변환은 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절할 뿐, 인스턴스에 아무 영향을 끼치지 않는다.<br><br>
-	어떤 타입에 대한 `instanceof` 연산의 결과가 true면 검사한 타입으로 형변환이 가능하다.<br><br>
-	메서드의 경우 참조 변수의 타입에 상관없이 실제 인스턴스의 메서드가 호출되지만, 멤버 변수는 참조 변수의 타입에 따라 달라진다.<br><br>

Abstract Class
--------------

-	추상 클래스는 미완성 추상 메서드를 포함한 미완성 설계도이다.<br><br>
-	추상 클래스에도 생성자와 멤버 변수 및 메서드를 가질 수 있다.<br><br>
-	추상 클래스는 인스턴스를 생성할 수 없으며, 상속을 통해 자손 클래스에 의해서만 완성된다.<br><br>
-	새로운 클래스를 작성할 때 지침이 된다.<br><br>

Interface
---------

```java
interface Test{
  public static final int num = 10;
  public abstract getRole(int val);
}
```

<br>

```java
public interface Vehicle {
    public int num = 10;

    public void test();
    public void test2();
}

abstract class Car implements Vehicle {
    public void test() {
        System.out.println("test");
    }
}

class Taxi extends Car {
    public void test2() {
        System.out.println("test2");
    }
}

interface Fightable extends Movable, Attackable {}
```

-	일종의 추상 클래스이지만, 추상화 정도가 높아서 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.<br><br>
-	오직 추상 메서드와 상수만을 멤버로 가진다.<br><br>
-	추상 클래스가 미완성 설계도라면, 인터페이스는 기본 설계도이다.<br><br>
-	멤버 변수와 메서드의 앞에 붙는 제약어는 공통 사항이지만, 이를 생략할 수 있다.<br><br>
-	그러나 static 메서드와 디폴트 메서드는 예외이다.<br><br>
-	만일 인터페이스를 상속 받은 클래스가 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여 추상 클래스로 선언해야 한다.<br><br>
-	인터페이스는 인터페이스로부터만 상속받을 수 있다.<br><br>
-	인터페이스를 통해 다중 상속의 장점을 실현할 수 있다.<br><br>

인터페이스의 장점
-----------------

-	1. 개발 시간을 단축시킬 수 있다.<br><br>
-	2. 표준화가 가능하다.<br><br>
-	3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.<br><br>
-	4. 독립적인 프로그래밍이 가능하다.<br><br>
-	5. User와 Provider 사이 관계를 간접적으로 만드는 캡슐화가 가능하여, 종속성 및 유지 보수 이슈를 다소 해결할 수 있다.<br><br>

Default Method & Static Method
------------------------------

```Java
interface MyInterface{
  void method();
  default void newMethod(){}
}
```

-	JDK 1.8부터 인터페이스에 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.<br><br>
-	인터페이스에는 추상 메서드만 선언할 수 있다는 원칙으로 인해 static 메서드들이 별도의 클래스로 관리되었으며, 대표적인 것이 Collections 클래스이다.<br><br>
-	디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.<br><br>
-	새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우, 필요한 쪽을 오버라이딩한다.<br><br>

Inner Class
-----------

```java
class Outer{
  class InstanceIneer{}
  static class StaticInner{}
  void myMethod(){
    class LocalInner{}
  }
}
```

-	내부 클래스는 클래스 내에 선언된 클래스이다.<br><br>
-	외부 클래스의 멤버들을 쉽게 접근할 수 있고, 캡슐화를 통해 코드의 복잡성을 줄인다.<br><br>
-	변수처럼 내부 클래스는 인스턴스 클래스, 스태틱 클래스, 지역 클래스 등으로 나뉜다.<br><br>
-	static 내부 클래스만 static 멤버를 정의할 수 있으나, final static은 상수이므로 다른 클래스들도 허용한다.<br><br>
-	지역내부 클래스는 다른 메서드에 같은 이름의 내부 클래스가 존재할 수 있기 때문에, 컴파일시 내부 클래스명 앞에 숫자가 붙는다.<br><br>

Anonymous Class
---------------

-	클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용되며, 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.<br><br>
-	익명 클래스는 이름이 없기 때문에 생성자가 없으며, 단 하나의 클래스 혹은 인터페이스를 구현할 수 있다.<br><br>

---

Reference
---------

-	Java의 정석 (남궁성 저) Chapter 6 - 7
