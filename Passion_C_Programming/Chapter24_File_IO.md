Chapter 24 : File IO
--------------------

---

### fopen<br>

```c
FILE * fopen(const char * filename, const char * mode);
//성공 시 해당 파일의 FILE 구조체 변수의 주소 값, 실패 시 NULL 포인터 반환
```

-	해당 함수를 통해 프로그램상에서 파일과의 스트림을 형성할 수 있다.<br><br>
-	FILE 구조체 변수에는 파일에 대한 정보가 담기며, 포인터는 사실상 파일을 가리키는 지시자의 역할을 한다.<br><br>

### fclose<br>

```c
int main(void){
  FILE * fp = fopen("data.txt", "wt");
  if (fp==NULL){
    puts("failure");
    return -1;
  }
  fputc('A', fp);
  fclose(fp); //스트림의 종료
  return 0;
}
```

-	실제로 스트림을 형성하는 주체는 운영체제이다.<br><br>
-	해당 함수는 개방되었던 파일을 닫아주는데, 이는 운영체제가 할당한 자원을 반환하고 버퍼링 되었던 데이터를 출력하기 위함이다.<br><br>

### fflush<br>

```c
int flush(FILE * stream);
//성공 시 0, 실패 시 EOF 반환
```

-	출력 버퍼를 비우는 함수이며, 입력 버퍼를 비우는 함수는 필요하지 않다.<br><br>

### 파일의 개방 모드<br>

![image](https://user-images.githubusercontent.com/56240505/71781082-fa48bb00-300d-11ea-9440-9100a4894182.png)<br><br>

-	읽기와 쓰기 및 텍스트 파일과 바이너리 파일 등의 스트림 기준을 통해 적합한 개방 모드를 선택하면 된다.<br><br>
-	+가 붙은 키워드는 읽기, 쓰기가 모두 가능한 스트림이지만 메모리 버퍼를 비우는 등 여러 불편함과 리스크가 존재하여 지양한다.<br><br>
-	운영체제마다 인식하는 개행의 표현이 상이하기 때문에, 텍스트 모드로 파일을 개방하면 치환이 발생한다.<br><br>
-	반면 바이너리 모드는 치환이 발생하지 않고, 개방 모드에 t도 b도 붙이지 않으면 파일은 기본적으로 텍스트 모드로 개방된다.<br><br>
-	문자열이 파일에 저장될 때에는 문자열의 끝을 의미하는 널 문자는 저장되지 않고, 파일은 개행을 기준으로 문자열을 구분한다.<br><br>

### feof<br>

```c
int feof(FILE * stream);
//파일의 끝에 도달한 경우 0이 아닌 값을 반환
```

-	파일 복사 프로그램과 같이 파일의 끝을 확인해야 하는 경우 유용하게 사용된다.<br><br>

### Reference<br>

-	열혈 C 프로그래밍 (윤성우 저) Chapter 24

---
