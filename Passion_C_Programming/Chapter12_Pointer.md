Chapter 12 : Pointer
--------------------

---

Pointer
-------

```C
int main(void){
  int num = 20;
  int * pnum = &num;
}
```

-	C 언어는 포인터를 통해 메모리에 직접 접근이 가능하기 때문에 Low-Level 특성을 지닌다고 말한다.<br><br>
-	변수 등의 데이터가 메모리 공간을 할당 받으면, 정수인 해당 공간의 주소 값 또한 저장할 수 있다.<br><br>
-	포인터 변수는 메모리의 주소 값을 저장하기 위한 변수이다.<br><br>
-	포인터는 크게 변수 형태의 포인터와 상수 형태의 포인터가 있다.<br><br>
-	`pnum`은 포인터 변수의 이름이며, `int *` 는 int형 변수의 주소 값을 저장하는 포인터 변수의 선언이다.<br><br>
-	포인터 변수의 크기는 시스템이 32비트인지 64비트인지에 따라 크기가 상이하다.<br><br>

Pointer Variable 선언
---------------------

```C
type * // type형 포인터
type * ptr; // type 형 포인터 변수 ptr
```

-	주소 값은 동일한 시스템에서 그 크기가 동일하며 모두 정수의 형태를 띄지만, 가리키고자 하는 변수의 자료형을 명시한다.<br><br>
-	이를 통해 포인터가 현재 가리키는 변수의 자료형을 짐작할 수 있다.<br><br>
-	포인터 변수도 값을 저장하는 변수이기 때문에 포인터 형 역시 자료형의 범주에 포함시키기도 한다.<br><br>
-	포인터 형이 존재하는 이유는 포인터 기반의 메모리 접근 기준을 마련하기 위함이며, 포인터에 형이 존재하지 않는다면 * 연산을 통한 메모리의 접근이 불가능하다.<br><br>

Operator &
----------

```C
int main(void){
  int num = 5;
  int * pnum = &num;
  double * pnum1 = &num; //일치하지 않음
}
```

-	`&` 연산자는 피연산자의 주소 값을 반환하는 연산자이며, 상수는 피연산자가 될 수 없다.<br><br>
-	변수의 자료형에 맞지 않는 포인터 변수의 선언은 컴파일 에러는 발생하지 않지만, 포인터 관련 * 연산 시 문제가 발생한다.<br><br>

Operator \*
-----------

```C
int main(void){
  int num = 10;
  int * pnum = &num;
  *pnum = 20;
  printf("%d", *pnum);
}
```

-	`*` 연산자는 포인터가 가리키는 메모리 공간에 접근할 때 사용하는 연산자이다.<br><br>
-	*pnum이 의미하는 바는 "포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 정수 20을 저장하고 출력하라." 이다.<br><br>

Null Pointer
------------

```C
int main(void){
  int * ptr1 = 0;
  int * ptr2 = NULL;
  int * ptr3 = 125;
  int * ptr4;
  *ptr4 = 10;
}
```

-	ptr4 포인터 변수처럼 포인터 변수를 선언만하고 초기화하지 않으면 쓰레기 값으로 초기화되기 때문에, 어느 메모리를 참조하는지 모른다.<br><br>
-	ptr3 포인터 변수는 잘못된 주소로 초기화가 되었다.<br><br>
-	ptr1, ptr2 처럼 0 혹은 NULL을 통해 아무데도 가리키지 않는다는 명시를 해야 하며, NULL 키워드는 상수 0으로 정의되어 있다.<br><br>

Reference
---------

-	열혈 C 프로그래밍 (윤성우 저) Chapter 12

---
